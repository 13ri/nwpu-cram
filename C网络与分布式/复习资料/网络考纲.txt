第一章
1、分布式系统的定义。
	由多个相互连接的计算机组成的一个整体
	这些计算机在一组系统软件的环境下，合作执行共同的或者不同的任务
	分布式计算系统=分布式硬件+分布式控制+分布式数据（HCD）


2、分布式系统的要求，开放性、可扩展性、异构性、透明性，每种特性掌握含义，主要表现，能举例说明。
	开放性：
		依赖于系统部件软件接口的规范说明和文档公开，基于统一的通信协议和
		遵循公开的访问共享资源的标准化接口。举例：服务通过IDL进行描述和访问。
	可扩展性：
		规模、地域、管理。
	异构性：
		网络、计算机硬件、操作系统、程序设计语言、不同开发商的实现
		隐蔽异构性的方法：
			中间件、虚拟机
	透明性：
		访问、位置、并发、失效、复制、迁移、性能、规模
	安全性：
		身份认证、消息加密、访问控制

3、中间件的概念，提供的服务等。
	一种独立的系统软件或服务程序。
	中间件屏蔽了节点计算机的差异，为应用程序提供了统一的运行环境。
	提供的服务：
		命名服务、作业调度、高级通信服务(RMI...)、资源管理、数据持久化、分布式事务、
		分布式文档系统、安全服务
========================================================================
第二章
1、实体的概念及其名字、地址等的具体含义。
	实体：在一个计算机系统中是指范围广泛的事物
	名字：是一个用户可读，便于记忆的字符串
	地址：实体的访问点，一个实体可以有多个访问点
	标识符：用于标识实体，提高访问效率，在系统内部唯一
	属性：一个实体有多个属性，用<类型-值>对表示
	上下文：在一个实体域中所有的实体的实体名和地址绑定的集合称为该域名字解析的上下文

名字空间：命名系统的名字集合
	增加名字项和绑定
	撤销名字项和绑定
	修改名字项和绑定
	名字解析

名字图的一个DAG图，有向无环图

挂接和挂载：
	外部名字空间的一部分或全部挂到本名字空间的某个目录节点上，
	本名字空间的目录节点称为挂接点，
	外部名字空间的目录节点称为挂载点
	
2、名字服务器的组成，名字解析的几种方法。
	名字服务器：实现和管理名字服务
	形式：
		名字服务（白页）：域名服务DNS、CORBA的命名服务
		目录服务（黄页）：X.500目录服务
		合约服务（绿页）：Web服务
	组成：（主要）
		数据库：实现实体名和地址的绑定，以及其他信息（名字解析上下文）
		名字解析软件
	组成：（详细）
			|  名字服务器操作   |
			|-----------------|	
			|    名字解析      | 
			| |缓存|多副本管理| |
			|-----------------|
			|通信|  数据库操作  |
		名字服务器操作
			上下文管理：增加、删除、修改上下文的目录项
			查询操作：读取、搜索和列表目录项
			行政管理：指定访问优先权、认证和名字空间扩展
		名字解析：根据名字解析请求，获取解析对象的地址
		缓存：缓存名字查询和解析的结果
		多副本管理：副本修改和副本一致性的维护
		通信：与客户端的名字代理通信、名字服务器之间的通信
		数据库：存放名字解析上下文或其子域

	名字服务器和名字代理（客户端）通过网络进行连接：
		名字服务器管理名字解析上下文、实现名字查询和解析、和其他名字服务器通信协调
		名字代理是名字服务器和客户之间的接口，它与名字服务器协调，生成名字解析上下文
		和进行名字解析，同时缓存名字查询和解析的结果。
	
	名字解析的方法：
		迭代名字解析
		递归名字解析
		
名字空间划分和多副本：
	上下文集中管理：
		整个名字服务的上下文集中由一个名字服务器（NS）管理，上下文信息保存在该
		名字服务器的集中数据库中。
		优点：易于实现，便于管理
		缺点：性能瓶颈，当客户增多，查询和解析效率会很快降低；容易形成单点故障
		
	上下文分布管理：
		将名字空间划分为多个名字域，由多个相应的名字服务器实现和管理。
		优点：分担了查询和解析负担，效率提高；避免了单点故障
		缺点：实现复杂
		
	多副本分布管理：
		在上下文分布管理的基础上，为每个名字域创建多个副本，分别存在不同的名字服务器中。
		优点：解决了名字服务的拥挤问题；避免名字服务的单点失效，提高性能
		缺点：带来了数据一致性的问题
				

3、白页服务、黄页服务、绿页服务的区别
	白页服务：根据实体的名字查找它的属性（地址）
	黄页服务：可以根据名字查找实体属性，也可以基于属性描述查找实体
	绿页服务：一种增强的黄页服务，通过技术规范来定位实体
4、目录服务X.500、LDAP
	名词：
		DIT 目录信息树：每个节点表示一个目录项（命名实体）
		DN  可区分名：唯一的标识一个目录项
		RDN 相对可区分名：由上级目录的可区分名和本目录的特别指定的属性值组成
		DIB 目录信息库：DIT的数据库存储（树的节点<->数据库一行目录项）
		DSA 目录系统代理：类似DNS
		DUA 目录用户代理：与DSA通信，执行DAP，获取目录信息
		DMD 目录管理域：被一个组织提供和维护的DSA和DUA的集合
	操作：
		目录查询：为客户提供目录查询服务，向客户提供目录信息
			成功，返回所需信息
			失败，返回失败信息
			转交，返回一个更适合的DSA（查询链）
		镜像操作绑定SOB：设置多副本，提供目录服务的性能和可用性
			DOP  目录操作绑定管理协议
			DISP 目录信息镜像协议
		层次操作绑定HOB：在DSA中建立层次关系，DIT在DSA之间被划分为不重叠的子树
			
	X.500有4个协议（都是应用层协议）：
		DAP  目录访问协议
			绑定、去绑定、读、比较、列表、搜索、撤销、增加目录项、取消目录项、修改目录项、更改可区分名
		DSP  目录系统协议
			和DAP的操作一一对应，属于两个DSA之间的请求/响应协议，可能经历多个DSA，
			所以DSP包含其他信息：
				访问者身份认证信息、跟踪信息，防止环路、请求返回交叉引用信息，优化目录服务
		DISP 目录信息镜像协议
			绑定、去绑定、合约镜像修改、请求镜像修改、修改镜像
		DOP  目录操作绑定管理协议
			绑定、去绑定、建立操作绑定、修改操作绑定、终止操作绑定
	
	LDAP模型的两种实现（P47）：
		LDAP服务器是一个独立的实体，用目录服务器提供的接口请求目录服务器执行查询操作。
		LDAP服务器是目录服务器的一个组成部分
		

挂载外部空间需要：
	访问协议的名称
	外部名字服务器的名称
	外部名字空间中的挂载点的名称

========================================================================
第三章
1、逻辑机模型
	两个部件：
		客户节点
		远程服务器节点
	客户机上的代理进程负责远程服务节点进程执行的初始化
	远程服务节点执行客户机赋予的进程
	在一个逻辑机边界内保持文件系统、进程的父子关系和进程组的进程视图的一致：
		远程进程必须能够访问驻留在源计算机上的文件系统
		远程进程能够接收逻辑机内任何进程发来的信号，也能将信号提供给逻辑机内任何进程
		进程组保持在逻辑机内
		基于树形的进程父子关系在逻辑机内必须保持
	
2、远程执行的过程，能以REXEC为例说明具体过程
	远程执行的要求：
		寻找管理机制，传播空闲机信息
		进程远程执行要是透明的，应与位置无关
		主人优先原则，当空闲机的拥有者要用时，应该停止远程执行，归还工作站
	REXEC由三个实体进行组织（P64 图3.4）：
		rexecd：运行在集群各节点上的守护进程
		rexec：客户进程，用户用来在REXEC上执行作业
			功能1-根据客户要求，选择节点
			功能2-通过SSL加密，与远程服务节点的rexecd建立TCP连接，实现在远程服务节点上执行用户进程
				（与远程服务节点的rexecd建立TCP连接，远程执行用户进程）
		vexecd：多副本的守护进程，提供远程服务节点的发现和选择功能，类似资源管理器
		过程：
			1.客户进程rexec向守护进程vexecd发起请求远程节点的请求
			2.vexecd从自己的数据库中，搜索两个轻负载的节点，返回结果给rexec
			3.rexec将客户进程在返回的rexecd节点上运行
	
	REXEC的实现（P65 图3.5）：
		rexec：node线程、stdin线程、signal线程
		rexecd：rexec线程、stdin\sig线程、stdout线程、stderr线程、心跳线程
	

3、进程迁移的过程，动态负载平衡如何实现。
	进程迁移：
		将一个正在运行的进程挂起，它的状态从源处理机节点转移到目标处理机节点，
		并在目标处理机节点恢复该进程运行
		优点：支持动态负载均衡、系统容错、高效使用本地资源
		缺点：运行开销较大
	进程迁移的两部分工作：
		1.在源处理机采集进程的状态并迁移到目标处理机，根据状态重建迁移进程，使之从断点处继续运行
		2.通知与迁移进程有通信关系的其他进程，帮助它们重建通信连接
	模型概念：
		进程状态：用户上下文、寄存器上下文、系统上下文
		原始主机：最初被递交运行的主机节点
		源处理机：相对于某次迁移之前，进程运行所在的节点
		目标处理机
		远程进程：运行在非递交处理机上的进程
		通信关系：进程之间的信息
	迁移步骤（机制）：
		主机协商 -> 进程冻结 -> 状态收集 -> 状态转移 -> 重新启动
		1.迁移协商：询问目标处理机是否可以接受迁移进程
		2.创建恢复进程：目标处理机同意后，在目标处理机上创建恢复进程
		3.进程冻结：中断进程的运行
		4.状态收集：在源处理机上收集迁移进程的状态
		5.状态转移：将收集的状态传输到目标处理机
		6.恢复状态：目标处理机上的恢复进程负责恢复迁移进程状态，重建进程实例
		7.重建通信：通知其他进程被迁移进程的新位置，重建迁移前的通信连接
		8.重新启动：迁移进程在目标处理机节点恢复运行
		9.操作转发：利用转发机制，保证进程可以在远程处理机透明执行
	
	动态负载均衡（进程迁移策略之一）：
		负载信息管理模块：
			主要决定和负载均衡相关的信息策略。
			信息策略：对负载信息的衡量和相关收集机制
				负载信息衡量：CPU利用率、运行进程个数、资源利用率...
				信息收集策略：
					周期性的\基于事件触发的
					集中式的\分布式的
		负载平衡模块：
			依据负载信息管理模型的负载信息，做出迁移决定
			传输策略：何时迁移进程
			选择策略：迁移何种进程
			定位策略：迁移到哪个节点
			常用负载均衡激发方式：
				中央服务器触发方式
				发送者触发方式
				服务者触发方式
				对称触发方式
				自适应触发方式
	
	进程迁移的实现：
		进程状态的收集和恢复：
			三种类型的状态收集接口形式：
				内部状态收集：进程状态收集函数写入程序代码，主动调用收集
				外部状态收集：需要将进程挂起，通过操作系统的接口收集
				触发式状态收集：在程序中设置迁移信号和信号处理函数，当进程收到迁移信号时，调用函数收集
		转发机制：
			进程迁移后，有些资源无法迁移过去，要通过转发到原始主机，进行处理
			VDCP
		通信恢复：
			通信丢失的三类问题（P72）：
				被迁进程到的新地址：
					解决方法：1.建立进程地址映射表 2.采用特殊路由方式
				保正不丢失任何消息：
					解决方法：1.消息驱赶方法 2.消息转发方法
				维护消息正确顺序：
					- 维护同一长消息的分片顺序
						解决方法：1.增加标志信息 2.原子通信
					- 维护不同消息的先后顺序：
						解决方法：1.消息附加消息序号 2.采用特定机制保住处于迁移临界区消息的正确顺序
		进程迁移算法（依据迁移过程中，其他非迁移进程的参与方式）：
			异步迁移算法：
				允许非迁移进程在迁移过程中继续运行
				优点：执行效率较好
				缺点：和原有环境的兼容性不好，不方便移植
				DynamicPVM：
					间接通信
					直接通信
			同步迁移算法：
				所有进程在迁移过程中都被挂起
				优点：有较好的可移植性和易于实现
				缺点：需要中央控制管理进程参与，所有进程被迫中断
				CoCheck：
					4个阶段：中断、同步、收集和恢复
			类异步迁移算法（MFQA）：
				所有进程也被中断，但是在迁移过程中可以继续运算，在某些时刻进行协调工作
				VDPC：
					保住消息不丢失和正确顺序：
						地址映射表
						消息驱赶机制
						消息转发机制
						缓存优先匹配机制
		

进程地址空间（P58）：
	正文区域（Code）：固定不可修改，存储进程代码
	数据堆区域（Heap）：由程序进行初始化，向高位扩展
	堆栈区域（Stack）：存放返回地址等，向低位延伸

分布式进程创建的支持设施为2个独立的系统服务：
	目标主机的选择
		位置策略
		传输策略
	执行环境的创建
		为新进程创建一个执行环境，主要是地址空间
		父进程地址空间的各个区域被其创建的子进程所继承

========================================================================		
第四章
1、通信原语，消息传送的几种模式及其对比。
	分布式系统通信：
		由一个通信层实现，建立在节点操作系统和网络传输层协议之上，提供一组通信原语
		供应用程序调用
	原语：
		由若干条指令组成，用于完成一定功能的一个过程，具有不可分割性。
	消息：
		分布式系统最基本的通信机制，其他通信机制都建立在消息机制之上。
	消息传送：
		两个基本原语：
			发送原语send(&x, destination_ID)
				M：消息体
				x：消息体M的存储单元
				destination_ID：接收进程的标识符
			接收原语receive(&y, source_ID)
				M：消息体
				y：消息体M的存储单元
				source_ID：发送进程的标识符
			消息={destination_ID, M, source_ID}
	消息传送模式：
		同步消息传送：
			进程P send 消息S 给 进程Q时，P必须等待Q执行对应的一条receive原语，
			将消息S接收到Q的存储单元R（执行receive也必须等待另一方执行send）
		阻塞发送/接收：
			进程P 执行一次send 无需等待对面的receive执行，当消息S安全写入
			发送缓冲区即可返回
			进程Q 执行一次receive ，当将消息S接收到Q的存储单元R之后，即可返回
			系统要为这个模式提供临时缓冲区
		非阻塞发送/接收：
			进程P 执行一次send，只要通知操作系统有一个消息要发送，即可返回
			进程Q 执行一次receive，只要通知操作系统有一个消息要接收，即可返回
			系统要为这个模式提供临时缓冲区
	
		通信事件      同步         阻塞         非阻塞
		发送启动条件  发送接收原语  发送原语达到   发送原语达到
					双方均达到
		发送返回指示  消息被接收    消息已发送	 消息发送启动
		语义          清晰		 居中	      易出错
		缓冲消息		 不需要       需要          需要
		状态检查      不需要		 不需要        需要
		等待开销      高			 居中	       低
		通信与计算    不能			 能	 		   能
		重叠
	
	消息可靠性语义：
		至少一次：保证正确完成消息传送至少一次
		至多一次：保证正确完成消息传送至多一次
		事务语义：保证消息的原子性
		精确一次：无论什么情况下，保证正确完成一次消息传送

组通信：
	组：由系统或用户确定的若干个进程的集合
	通信方式：
		点对点通信：单播
		一到多通信：多播、广播
	进程组的分类：
		- 封闭组和开放组
		- 对等组和分层组
	组通信应用：
		多副本容错
		提高多副本数据修改效率
		自发连网的服务发现
		事件通知传播

可靠的组通信：
	基本的可靠组通信：
		解决组播消息丢失的方法：
			1.发送进程为组播消息赋予序号，按顺序发送，接收的序号不连贯，说明有消息丢失。
			2.接收进程接收消息后检查序号，如果连贯，返回“成功接收”；否则，返回“消息丢失”。
			3.发送进程维护一个历史缓冲器，保留发送过的组播消息。当收到“消息丢失”的应答，点对点进行丢失消息重发。
	可靠多播的扩展性：
		不分层反馈抑制:
			当有一个接收进程的消息丢失，就会向所有组成员发送“消息丢失”响应，其他组成员
			接收到这个响应，就不会再发送“消息丢失”，发送进程接收到一个“消息丢失”反馈，就会
			重发丢失的组播消息
		分层反馈抑制：
			每个进程小组指定一个协调者，负责处理本小组接收进程的重复请求；
			如果协调者自己丢失了多播消息，它就请求其父亲小组的协调者重发消息。
	原子组播（P88）：
		保证要么消息发送给所有成员，要么一个都不发送，还要求发送的消息顺序都一致。
		虚拟同步：多播消息m应唯一的与m要传送到的一个进程组列表关联
			可靠多播的原子性
			虚拟同步可靠多播
		消息排序：
			可靠不排序组播
			可靠FIFO排序
			因果排序
	
2、RPC的概念，远程调用的过程，参数的传递等。
	RPC：远程过程调用，一个节点请求另一个节点提供的服务
	调用的过程：
		1.client应用程序正常调用client stub
		2.client stub构造消息，通过trap进入操作系统内核
		3.内核将消息发送给server操作系统内核
		4.server内核将消息交给server stub
		5.server stub将消息解包，用相应参数调用服务例程
		6.服务例程进行计算，将结果返回给server stub
		7.server stub构造消息，通过trap进入内核
		8.内核将消息发送给client操作系统内核
		9.client内核将消息交给client stub
		10.stub解包，将结果返回给对应的进程
	参数传递：
		数据格式问题的解决方法：
			- 统一规范格式，简单但不灵活，效率也不高
			- 增加一个参数，或在消息中指明格式，由接收者做相应的处理，效率较高，但
			每个机器需配置完全的格式转换程序
		指针类参数问题的解决方法：
			- 全部禁用，不利于用户使用
			- 复制存储方法，client用实体代替指针，server生成缓冲区存放实体，计算后将
			缓冲区打包发回
		复杂数据类型问题的解决方法：
			- 定制专门的通信协议，详细描述数据规格，并配置相应程序读取

	RPC的语义：
		客户不能定位服务器：
			客户桩向客户返回一个“找不到服务器”异常，或设置“找不到服务器”标志
		请求消息丢失：
			计时器机制，超时则触发中断，重发请求，多次超时则放弃调用
		应答消息丢失：
			计时器机制，需判断服务器操作是否幂等
		服务器崩溃（三种观点）：
			至少一次语义（重发请求）
			至多一次语义（立即放弃并报告失败）
			不做任何保证
		客户崩溃（P96）：
			清剿
			转世
			温和转世
			期满
	
DCE-RPC：
	DCE：分布式计算环境，由多个服务构成
		分布式文件服务
		目录服务
		安全服务
		时间服务
	DCE绑定过程：
		1.注册端口
		2.注册服务
		3.查找服务器
		4.查找端口
		5.客户有了应用服务器的网络地址和端口号，就可以与应用服务器进行RPC通信。
		
	
IDL语言：
	IDL文件是一个接口文件，文件中指定全局唯一标识符，是一种用来说明操作，
	操作的参数和数据类型的语言，IDL编译以后形成：头文件，客户桩文件，服务器桩文件。
	
分布式事件通知：
	事件参与者
	事件分送保证语义
	观察者角色
	
JINI事件通知：
	事件涉及的对象
	事件接口
	第三方代理

远程对象方法调用：
	客户和对象绑定：
		远程对象引用（Remote Object Reference）是访问远程对象的一种机制，
		ref={网络地址，端口号，内部ID}：
			对象实际驻留节点的网络地址
			管理该对象的服务器端口号（进程）
			服务器为该对象提供的内部ID
		客户与对象绑定：
			隐式绑定：允许用户只使用对象引用的情况下，直接进行对象方法的调用
			显式绑定：用户必须首先调用某个特定函数来绑定到对象上，才能调用对象的方法。
		对象通信（P100）：
			本地调用：调用和被调对象在同一个进程中
			进程外调用：调用和被调对象在同一节点但不同进程
			远程调用：调用和被调对象在不同节点
	远程方法调用：
		静态方法调用：预先使用接口定义语言确定接口，生成客户端代理和服务器端骨架
			客户端代理（proxy）：
				- 由客户应用进程调用，对调用参数编码，打包发送给服务器
				- 接收服务器应答消息，对结果解码，返回给客户进程
			服务器端骨架（skeleton）：
				- 接收客户端请求消息，解码调用参数，调用对象方法
				- 接收对象返回的调用结果，编码，打包发送给客户端
		动态方法调用：运行时建立对象方法的调用
		远程方法调用语义：
			方法调用的分送保证的选择（容错方案）：
				- 重试请求消息：是否重发请求消息，直到接收了应答或者服务器失效
				- 对重复进行滤波：当重发请求时，服务器是否对重复的请求进行过滤
				- 结果重传：是否保留结果的历史，以便重传结果而又不使服务器重复执行操作
			语义：
				可能（Maybe）（只用在失效调用可接受的场合，没有容错能力）：
					调用者不知道远程方法是否被执行过一次或完全没执行
				“至少一次”（可以用在服务器都是等幂操作的环境中）：
					调用者或者接收一个结果，方法至少执行一次；
					或者接收到一个例外通知，告知它不会有结果。
					可以通过重传请求消息实现。
				“至多一次”：
					调用者或者接收一个结果，方法精确执行一次；
					或者接收到一个例外通知，告知它不会有结果。
					这时方法可能执行了一次或没执行。
			重试请求消息  |  对重复进行滤波  |  再次执行或应答重传  |  操作语义
			     否     |       不用      |         不用       |   可能
			     是     |        否       |       再次执行     |  至少一次
			     是     |        是       |       应答重传     |  至多一次 
	
3、RMI的概念，调用过程，参数传递等。
	远程方法调用，是java特有的分布式计算技术。实质上通过Java扩展了常规的过程调用，
	在网络上不仅可以传送对象的数据，而且可以传送对象的代码。
	RMI是RPC模型的面向对象实现。
	使用RMI，对象服务器通过目录服务导出和注册远程对象，通过远程接口声明远程对象，
	提供远程方法调用。
	
	RMI体系结构（P348）：
		RMI应用程序由服务器和客户端组成，都包括3层抽象：
			桩/骨架层（Stub/Skeleton）
			远程调用层（Remote Reference Layer）
			传输层（Transport）
		RMI和RPC的区别：
			RMI只允许使用Java、RMI是针对面向对象编程、支持对象的传递
			RPC是传统意义上的过程调用
		RMI的主要的三部分：
			RMI客户端：可以调用远程对象的方法
			RMI服务器：对外提供远程对象
			Rmiregistry：jdk提供的一个可以独立运行的程序，在bin目录下
		RMI工作流程：
			1. 远程对象注册与名字绑定
			2. 客户按名字查找远程对象
			3. 注册器返回远程对象接口
			4. 客户从codebase请求stub类
			5. http服务器返回远程对象的stub类
	
	RMI应用开发：
		通常RMI系统由下面几个部分组成：
			- 远程服务的接口定义
			- 远程服务接口的具体实现
			- 桩（Stub）和骨架（Skeleton）文件
			- 一个运行远程服务的服务器
			- 一个RMI命名服务，它允许客户端去发现这个远程服务
			- 类文件的提供者（一个HTTP/FTP服务器）
			- 一个客户端程序
		可以跨虚拟机调用的方法的对象叫远程对象，一个远程对象实现一个远程接口，
		远程接口的特征：
			由java.rmi.Remote派生
			除了特殊异常外，接口中每个方法都要声明一个java.rmi.RemoteException异常
		分布式应用开发步骤：
			1. 设计和实现你的分布式应用的组件
				- 定义远程接口
				- 实现远程对象
				- 实现客户端
			2. 编译源程序并生成头文件
			3. 通过网络访问得到所需要的类
			4. 启动应用程序 
		RMI交互图（PPT）：
			1. Server创建远程对象
			2. Server注册远程对象到RMI Registry
			3. Client访问服务器并查找注册的远程对象
			4. Registry返回服务器远程对象的存根（stub）
			5. Client调用远程对象（stub）的方法
			6. 客户端本地存根（stub）和服务器骨架（skeleton）通信
			7. 骨架代理调用方法
			8. 远程对象返回方法的执行结果给骨架
			9. 骨架返回结果给存根
			10. 存根把结果返回给Client

	RMI示例：
		远程接口 IRemoteMath.java
		import java.rmi.Remote;
		import java.rmi.RemoteException;
		
		/**
		* 必须继承Remote类
		* 所有参数和返回类型必须序列化（implements Serializable）（因为要网络传输）
		* 任意远程对象必须实现此接口
		* 只有远程接口中指定的方法可以被调用
		*/
		public interface IRemoteMath extends Remote{
			
			// 所有方法必须抛出RemoteException
			public double add(double a, double b) throws RemoteException;
		}
		----------------------------------------------------------------
		远程接口实现类 RemoteMath.java
		import java.rmi.RemoteException;
		import java.rmi.UnicastRemoteObject;
		
		/**
		* 服务器端实现远程接口
		* 必须继承UnicastRemoteObject，以允许JVM创建远程的代理
		*/
		public class RemoteMath extends UnicastRemoteObject implements IRemoteMath{
			
			@Override
			public double add(double a, double b) throws RemoteException{
				return a+b;
			}
		}
		----------------------------------------------------------------
		服务器端 RMIServer.java
		import java.rmi.registry.LocateRegistry;
		import java.rmi.registry.Registry;
		
		/**
		* 创建RemoteMath类的实例，并在rmiregistry中注册
		*/
		public class RMIServer{
			public static void main(String[] args){
				try{
					// 注册远程对象，向客户端提供远程对象服务
					// 远程对象是在远程服务上创建的，你无法确切地知道远程服务器上的对象的名称
					// 但是，将远程对象注册到rmi registry之后
					// 客户端就可以通过rmi registry请求到该远程对象的stub
					// 利用stub代理就可以访问远程对象了
					IRemoteMath remoteMath = new RemoteMath();
					LocateRegistry.createRegistry(1099);
					Registry registry = LocateRegistry.getRegistry();
					registry.bind("Compute", remoteMath);
					// 如果不想再让对象被继续调用，使用下面这行
					// UnicastRemoteObject.unexportObject(remoteMath, false);
				}catch(Exception e){}
			}
		}
		----------------------------------------------------------------
		客户端 MathClient.java
		import java.rmi.registry.LocateRegistry;
		import java.rmi.registry.Registry;
		import java.rmi.Naming;
		
		public class MathClient{
			public static void main(String[] args){
				try{
					// 如果RMI Registry就在本地，URL就是：rmi://localhost:1099/Compute
					// 否则，URL就是：rmi://RMIService_IP:1099/Compute
					Registry registry = LocateRegistry.getRegistry("localhost");
					// 从Registry中检索远程对象的代理
					IRemoteMath remoteMath = (IRemoteMath)registry.lookup("Compute");
					// 获取代理的另一种方法
					// IRemoteMath remoteMath = (IRemoteMath)Naming.lookup("rmi://localhost:1099/Compute");
					// 调用远程对象的方法
					double res = remoteMath.add(5.0, 3.0);
				}catch(Exception e){}
			}
		}
		

========================================================================
第五章
1、逻辑时钟的概念，Lamport时间戳、向量时间戳。
	逻辑时钟：
		只要计算机内部各时钟一致即可，而不管是否与真实时间接近。
		
	Lamport：
		重要的不是时间一致，而是时间发生的顺序一致
		“先发生”：a->b
			1- a、b在同一进程，且a在b之前发生
			2- a是一个进程的发送消息事件，b是另一个进程接收对应消息的事件
			3- a、b发生在两个互不交互的进程中，称a、b并发，没有先后关系
			4- “先发生”有传递性：若a->b,b->c，则a->c
		Lamport逻辑时钟C(x)：
			通过一种测量时间的方法，为每一个事件x分配一个所有进程都认可的时间C(x)，
			C(x)是递增的，不存在两个值一样的C(x)
			时间条件：（1-或者2-情况成立，时间条件满足）
				if a->b:
					C(a) < C(b)
			实现规则（P114 图5.6）：
				IR1：进程Pi的后一个事件b等于前一个事件a的时钟加1
					if a->b:
						C(b) = C(a) + 1
				IR2：用于保证分布式逻辑时钟的一致性，每个消息m必须带上一个时间戳Tm，
					它是消息发送事件的逻辑时钟值。当带Tm的消息m被接收时，接收进程比较
					自己的逻辑时钟C(b)和时间戳Tm的大小，来修改它的逻辑时钟值。
					IR2(a)：事件a是 进程Pi发送消息m，m包含时间戳Tm=Ci(a)
					IR2(b)：进程Pj接收m，执行Cj(b) = max{Cj(b), Tm+1}
			逻辑时钟全定序：
				通过时间戳对所有事件排序，为这些事件定义一个全局时间戳(Ti, i)和(Tj, j):
					(Ti, i) < (Tj, j)  当且仅当 Ti < Tj 或 Ti = Tj, i < j
				可以用来对进入临界区的进程排序。
	向量时间戳（捕获因果关系）：
		通过让每个进程维护一个向量V来实现的，V具有三个性质：
			1. V是一个数组，数组的元素个数是系统的进程数，元素是升序的整数，
				在数组中按进程号排序。系统每个进程维持一个向量时钟
			2. Vi[i]是目前为止，进程Pi发送的事件个数
			3. Vi[j]=k，进程Pi就知道进程Pj中已经发生了k个事件，这是通过发送消息时
				携带向量V实现的
		向量时钟的走动规则（P115 图5.7）：
			VC1：初始化，Vi[j] = 0。
			VC2：进程Pi在为它的事件加上时间戳T之前，使Vi[i] = Vi[i] + 1
			VC3：进程Pi发送消息时，将它的向量时钟ti与消息m一起发送
			VC4（个人理解，和书上不一样）：当进程Pj接收消息时，它设置其向量时钟为Vj[k]=Max{Vj[k], ti[k]}(k!=j)，
				即两个向量时钟相应元素取最大值，并且Vj[j] = Vj[j] + 1
			
2、常用选举算法。
	选择一个进程来担当协调者的算法
	环算法：
		适合安排成逻辑环的进程集合，消息在环中顺时针传送，选举一个具有最高编号的进程作为协调者
		假定选举过程不会失败，通信是异步的
		- 最初，每个进程标记为未参与者
		- 选举发起者将自己标记为参与者，将自己的标识符置于选举消息中，顺时针传给下一个进程
		- 当进程收到一个选举消息，它将选举消息中的标识符和自己的比较，如果消息中的标识符大，
			进程转发这个选举消息到下一个进程，将自己标记为参与者
		- 如果消息中的标识符小，且接收进程是未参与者，接收进程用自己的标识符替换消息中的标识符，
			将消息转发到下一个进程，自己成为参与者
		- 如果消息中的标识符小，接收进程是参与者，它只转发消息，直到接收进程和消息中的
			标识符相同为止
		- 标识符中标识符最高者就是新的协调者
		最坏情况：最高编号进程A是启动进程B的逆时针邻居，要先经过N-1次转发，达到A；
			然后再转发N次，确定它是最大编号进程；最后要转发N次，宣布它是新协调者，
			总共需要转发3N-1次
	欺负算法：
		允许进程在选举过程中失效，通过超时机制检测。启动进程只和编号高于它的进程通信。
		该算法采用同步方式，认为消息传输是可靠的。
		三种消息：选举消息Election(E)、应答消息OK、协调者消息Coordinator(C)。
		当一个进程P发现协调者不再响应请求时，它就启动一次选举，选举过程如下：
			- 进程P向所有编号比他高的进程发送一个选举消息E
			- 如果T时间内没有进程响应，则P是编号最大的，成为新的协调者(T=2Ttran+Tprocess)
			- 如果有进程响应，响应进程接过选举主持工作，进程P工作结束
			- 一个进程只能从编号小于它的进程处接收到消息E，然后返回应答OK，接替选举。

3、几种常用的互斥算法，能灵活运用，并根据需求改进。
	集中式算法：
		选一个进程为协调者，一个进程要进入临界区，需要向协调者发送一个请求消息，
		如果当前资源没有进程访问，协调者就发送应答消息，允许申请者进入临界区
		协调者：确定哪一个进程可以访问资源
		通信量：请求Request-许可Reply-释放Release，顺序执行，没有资源饥饿
	基于时间戳算法：
		Lamport算法：
			对系统中是事件完全排序，当一个进程访问一个共享资源时，要构造一个消息，
			包括：资源名、进程号、当前逻辑时间，需要区分三种情况：
				- 若接收者没有访问资源，也不想访问资源，则向发送者发送OK消息
				- 若接收者已经获得资源，则不必回答，只负责对请求队列排序
				- 若接收者想要访问资源，但还没进入，它要将发来的消息和它发送给其余
					进程的时间戳对比：
					- 如果来的消息的时间戳小，接收者发送OK消息
					- 如果接收者本身的时间戳小，那么接收者负责排列请求队列而不发送消息
			实现：
				假设：N个进程共享一个资源，资源单个进程独占
				算法需要满足的条件：
					- 拥有资源的进程需要放弃资源，其他进程才可以使用
					- 按照进程请求的次序批准其使用资源
					- 资源能够被释放
				算法假设：
					- Pi向Pj发送消息，Pj按发送消息的顺序接收消息
					- 每个消息都能被接收
					- 消息是直接发送的，无中转
				1. Pi资源请求消息Request(Ti: Pi)发送
				2. Pj收到Request(Ti: Pi)，按T顺序置于其消息队列，如果没有资源请求
					或者请求时间晚于收到消息的时间戳，回应Reply(Tj: Pj)
				3. Pi被批准使用临界资源的条件：有请求，且Ti最小；Pi接收了所有晚于Ti的消息（包括应答）
				4. Pi释放临界资源，删除(Ti: Pi)，发送Release(Tj+1: Pi)
				5. Pj收到Release后，删除(Ti: Pi)
			开销：3(N-1)个消息，N是参与资源共享的进程数
		Ricart_Agrawala算法：	
			保证互斥、不发生死锁和饥饿的条件：
				- 每个进程知道共享资源的其他进程的标识符。要求每个进程维护一个数据库，
					节点的加入在数据库中建立一个表项，包含标识符以及加入、退出和失效等状态信息
				- 要求监视所有进程状态，如果发现一个进程失效，就通知其他进程，以后的
					资源请求消息不要发送给失效和退出的进程
			实现：
				1. Pi发送资源请求消息Request(Ti: Pi)
				2. Pj收到Request(Ti: Pi)，按照Ti顺序置于消息队列
					- 如果没有资源请求或者资源请求晚于收到的消息时间戳
						回应Reply(Tj: Pj)；否则推迟返回应答消息
					- 进程从临界区退出，向有关请求资源的进程补发一个应答消息
				3. 请求进程从其他竞争进程得到应答Reply(Tj: Pj)，便可进入临界区
			开销：2(N-1)个消息，N是参与资源共享的进程数
	令牌环算法：
		只有拥有令牌的进程才能进入临界区，访问资源。
		逻辑环结构：
			静态建立逻辑环，每个进程必须知道它的逻辑前驱地址 或 逻辑后继地址。
			以后继地址为例：
				进程接收一个带地址标识addr的令牌后，检查该地址是否为Pi的地址，如果
				addr=i，检查进程是否要进入临界区，如果是，则进入临界区，退出临界区后
				将addr置为进程的后继。路由算法得到下一个节点的地址；
				如果addr!=i，路由算法得到下一个节点的地址。
			优点：确保每次只有一个竞争进程进入临界区，最多只需N-1个消息
		无环结构（Chandy算法）：
			持有令牌的进程可以把令牌发送给其他任何进程
	
	基于事件优先权算法：
		上面基于时间的算法不适合实时分布式系统，本算法适应优先权（进程优先权，P系统）系统和
		实时（进程执行残留时间，RT系统）系统

		完全可靠网络算法：
			每个节点上存在两个请求队列P和Q：
				P：放置其他节点来不及处理的随令牌转来的请求
				Q：放置其他节点送来的请求
			过程：
				- 进程i希望进入临界区，发送Request(i, P(i))到其他所有竞争进程，
					并将(i, P(i))存入接收进程的Q队列，队列内按照优先关系“>>”排序
				- 拥有令牌的进程j退出临界区，检查本地的队列Q和随令牌同时被接收的队列P：
					如果P和Q都空，表面没有进程要进入临界区，j正常工作，直到接收其他进程的请求
					如果P空，Q不空，则在Q中标注最高优先权的进程，合并队列形成新的P队列
					如果P不空，Q空，则在P中标注最高优先权的进程，合并队列形成新的P队列
					如果都不空，则在Q中标注最高优先权的进程，合并P和Q队列形成新的P队列
				- 进程j将令牌和新的P队列发送给所标注的最高优先权的进程
					
		不可靠网络算法：
			实际情况：节点（进程）可能失效；消息丢失或者不按顺序发送
			在实际情况下，互斥算法应该：
				- 最多一个竞争进程进入临界区，且机会均等
				- 按进程优先关系而不是按出现的先后被批准进入临界区
				- 提供节点失效检查恢复机制
				- 进入和退出竞争进程组的开销要小，不增加消息数
			算法过程和可靠网络算法基本一致，但需要一个超时恢复机制：
				- 当进程j在发送令牌到另一个进程i时，启动超时机制
				- 如果进程j在超时范围内没有接收到进程i的应答消息，就认为i失效，
					修改队列P（删除进程i），发送一个令牌和新的队列P给下一个进程
	共享K个相同资源的算法（Raymond算法）：
		由于一种共享资源可能有多个副本（K个），该算法允许K个进程同时进入临界区。
		N-1个竞争进程中，少于K-1个进程在临界区中，则另一个进程可以进入临界区，
		但是需要得到N-1-（K-1） = N-K个应答消息


分布式时钟同步类型：
	外同步：分布式系统节点的时钟和外部全球真实时钟同步
	内同步：分布式系统各节点之间的时钟同步

时钟同步算法：
	在Unix系统里面，Make命令，只是用来编译新修改过的代码文件。
	Make命令使用运行的客户端的时钟来决定哪个文件是被修改过的。
	但是，如果把代码放到文件服务器上面，而运行make命令的主机与文件服务器的时间不同的时候，
	make命令就有可能工作不正常。
	Cristian's 算法：
		询问时同步
		时间绝不能倒退（可以让时间走慢点，“等待”后面的时钟）
		逐步修正
		服务器被动
		
		在一个进程P向一个时间服务器S（装有WWV接收器的机器）请求时间：
			- P发送一个请求包到S，请求时间
			- S收到P的请求包后，在包上面加上当前S的时间T，回发过去
			- P收到数据包之后，将当前时间设置为T+RTT/2
		基于只在一台机器上装有WWV接收器
		
		问题：
			时间不能往后拨
			传输消息的网络延时对时间校准的影响
			单点故障
		
	berkeley 算法：
		轮询-发布式同步
		服务器主动
	
		几个客户端之间同步时钟：
			- 通过算法，在一个环里面选举一个节点作为Matser
			- 一个Master使用Cristian's 算法来请求各节点的时间
			- Matser通过记录时间的平均值，同时剔除偏差很大的时间来评估每个节点的时间偏差
			- Matser发送每个节点的时间偏差到每个节点，让节点自行矫正
		适合没有安装WWV接收器的系统

网络时间协议（NTP）：
	用来使计算机时间同步化的一种协议
	NTP服务是由跨Internet时间服务器网络提供。时间服务器在逻辑上组成树型的同步子网结构。
	
	三种同步方式（采用UDP传输消息）：
		多播模式：
			在LAN中，一个或多个服务器周期性多播时间信息给LAN中的计算机。
			精度较低，但是对于多数应用够用
		过程调用模式：
			一个时间服务器接受其他计算机的请求，然后回答它当前的时间读数。
			精度高于多播模式，在同一或者临近LAN上的文件服务器需要精确定位时间时，可以用此模式
		对称模式：
			为局域网上提供时间消息的服务器和高层同步子网所用，后者可以达到最高的时间精度。
		

========================================================================
第八章
1、几种一致性模型，每种模型的具体表述，能绘图说明。
	一致性模型：
		是数据存储和访问数据存储的进程之间的一种契约。
	
2、分发协议，几种不同副本的概念，作用等。
	永久副本
		由数据存储的拥有者创建和管理，且作为数据拥有者的数据固定存储。目的：满足容错要求
	服务器启动的副本
		应数据拥有者的请求，根据永久副本而创建的。目的：增强系统的性能。
	客户启动的副本
		客户启动的副本。目的：提高系统性能，缩短访问时间。

拉协议和推协议
	基于推的方法也称基于服务器协议，不需要其他副本的更新请求，这些数据更新便可传播到
		所有副本。
	基于拉的方法也称基于客户协议，一台服务器或客户请求其他服务器发送此时它持有的数据更新。

租赁：
	租赁是服务器做出的承诺，它指定一个租赁期将更新推给用户。当租赁到期，
	客户被迫轮询服务器以实现更新；或在到期前，请求一个新的租赁，从服务器得到数据。
	

3、更新传播的几种方式及其对比。

数据存储多副本的目的：提高系统的可靠性和性能 
	提高系统的容错能力
	提高系统效率
	增强系统可扩展性

一致性协议
	主从副本协议
		远程单副本协议：共享数据项只有一个副本，且驻留在远程副本服务器中。所有读写
			操作都要转发到这个副本服务器上执行。
		远程主副本协议：数据项有多个副本，但只有一个主副本。写操作都转发到主副本上执行，
			主副本通知其他副本修改数据；读操作在本地副本执行。（主机备份协议）
		迁移读/写协议：共享数据项只有一个副本，且驻留在一个副本服务器。所有读写操作
			都要转发到这个服务器上执行。每次执行之前，数据项必须从原驻服务器迁移到
			读写进程的本地服务器。
		迁移主副本写协议：数据项有多个副本，但只有一个主副本。写操作将主副本迁移到写进程
			副本服务器上执行，然后通知其他副本对数据进行修改；读操作在本地副本上执行。
	复制写协议
		主动多副本协议：写操作的副本更新要传送到数据存储的每个副本，每个副本的更新操作
			定序要相同。
				带时间戳的原子组播
				中央定序器
		基于法定数量的协议：
			Gifford表决算法：一个客户要读取一个具有N个副本的文件，必须将NR个服务器组成一个“读集团”；
				要修改一个文件，必须将NW个服务器组成一个“写集团”。NR和NW必须满足：
					- NR+NW > N  防止读写冲突
					- NW > N/2   防止写写冲突
	高速缓存相关性协议

========================================================================
第九章
1、网络文件系统的相关内容。

分布式文件系统：
	概述：
		分布式文件应支持透明性要求，客户与文件服务器处在不同的网络节点上，客户端通过挂接访问共享文件
		为了容错，采用多副本技术；为了提高文件系统性能，采用多副本和客户端缓存技术。
	抽象模型：
		客户端
		服务端
			文件服务
			目录服务
		互连网络
	设计问题：
		文件使用模式
		命名与名字解析
		结构与接口
		缓存策略与一致性
		文件共享语义
		断开操作与容错
		
2、NFS RPC重传的几种情形。
3、AFS/Coda实现客户端缓存一致性的方法。
========================================================================
第十一章
1、OMA参考模型，·的组成，几种接口的作用。	
	OMA（对象管理结构）参考模型：
		目的：在分布式对象互操作前提下，定义一个分布式组件（对象）体系结构的接口和协议，
			以支持互操作应用程序的设计和开发。
		OMA由对象模型（Object Model）和参考模型（Reference Model）组成：
			对象模型：定义和描述分布式组件（对象）
			参考模型：定义组件（对象）之间在分布式异构环境中如何交互
		ORB和GIOP：
			ORB：对象请求代理，提供了网络环境无关性、操作系统无关性和开发语言无关性的公共平台。
			GIOP：通用对象代理协议，解决异构环境下分布式对象互操作的问题。
			当前普遍使用的IIOP是运行在TCP/IP协议层之上的GIOP。
			CORBA的核心就是ORB，CORBA的远程对象方法调用依赖GIOP。
		CORBA公共对象服务：
			独立于应用领域，为使用和实现对象而提供的基本服务集合。
			在构建分布式应用时，经常会用到这些服务。
		CORBA公共设施：
			提供一组更高层的函数，为终端用户应用提供一组共享服务接口。
		CORBA领域接口：
			与特定的应用领域有关，如为制造业、通信行业等领域服务提供接口。
		应用接口：
			由销售商提供的、可控制其接口的产品，相当于传统的应用表示。

	CORBA（公共对象请求代理结构）:
		目的：允许分布式对象在异构环境下互操作。
		CORBA是OMA的一部分，作为规范分布式对象间互操作的标准
		CORBA的核心是对象请求代理ORB
		在面向对象的应用环境中，CORBA的请求者不必知道它所请求的对象在哪，
			而是由ORB来负责跨平台的运作管理，无须开发者干预。
		具有跨平台、分布式、面向对象等优点
		CORBA是一个中间件规范，不是一个实体软件。软件开发者通过第三方的ORB工具
			或IDL语言来定义CORBA对象，实现ORB功能
		IDL：
			为了保持CORBA的商业中立性和语言中立性，必须有一个中介，存在于像
			C++ CORBA服务器代码和Java CORBA客户机这样的实体之间，这就是IDL
			IDL语言是中立的，因此可以利用任何已经作了IDL映射的程序设计语言。
			
		CORBA的体系结构：
			ORB：对象请求代理
				- 作为软件总线来连接网络上的不同对象
				- 提供对象的定位和方法调用
			OA：对象适配器
				- 用于构造对象实现和ORB之间的接口
				- 给框架发送方法调用
				- 支持服务器对象的生命周期（对象的创建和删除）
			BOA：基本对象适配器
				- 当客户请求对象的服务时，负责激活对象
			POA：可移植对象适配器
				- BOA的代替方法，提供高级特性和大量可扩展的接口
				- 支持透明激活对象
				- 允许单个服务者支持多个对象标识
				- 允许一个服务者上有多个POA，每个都有自己的一套管理策略
				- 将对不存在服务者的请求委托给默认服务者，或者向服务者的管理器请求一个合适的服务者
			GIOP：通用ORB间通信协议
				- 定义了ORB之间的交互接口
			IIOP：互联网ORB间通信协议
				- IIOP把GIOP消息数据映射为TCP/IP连接行为和输入/输出流的读/写操作
			IOR：可互操作对象引用
				- 包括所有客户与服务器联系所需的各种信息
				- 格式：[IDL接口类型名|IIOP|主机域名|TCP端口|适配器名|对象名]
				- IIOP|主机域名|TCP端口 是配置文件段
				- 适配器名|对象名 是对象键段
			接口公用库：
				- 持久地存储IDL的接口说明
				- 实现对象继承性层次结构的导航，提供了有关对象支持的所以操作的描述
				- 为接口浏览器提供信息，帮助应用开发者找出潜在的可重用的软件部件
				- 提供类型信息，为动态调用接口发送请求提供信息支持
			动态调用接口：
				- 把IDL说明编译成面向对象语言的实现代码后，客户可以调用已知对象的操作
				- 在某些应用中，用户并不了解应用接口编译信息，但也要求调用对象的操作，这时
					就要动态调用接口来调用用户的操作
			CORBA服务：
				创建CORBA服务
				为服务创建ORB对象
				注册服务
			CORBA客户：
				使用名称服务器来查找服务
				请求远程对象方法
		
		CORBA的组成（P326）：
			ORB核心：
				实现对所以ORB都相同的接口
				这些接口是在CORBA规范中预先定义的，为所有ORB实现支持
				接口包括：动态调用接口、动态框架接口、ORB接口
				ORB接口是直接为应用程序使用的本地服务接口
			对象适配器接口：
				CORBA可移植对象适配器POA的作用是连接对象实现和ORB
				POA本身是一个对象，它使被调用对象的接口适配于调用对象所期望的接口
				对象适配器的作用：
					对象登记，POA提供操作允许用POA登记CORBA对象实现
					对象引用生成，POA可生成CORBA对象引用
					若请求到达时，该CORBA对象不是激活状态，POA可激活该对象实现
					多路请求，POA和ORB协作保证请求通过多路连接被接受而
						不会在单连接上阻塞
			接口定义语言和静态接口：
				客户用ORB携带的IDL编译器，编译对象接口IDL文件，生成特定语言的Stub和Skeleton代码
				Stub负责：编码请求，以ORB形式发送给对象实现，解码返回结果，传给客户
				Skeleton负责：解码请求，执行对象实现，编码返回结果，以ORB形式发送给客户
			动态接口：
				在预先不知道的服务对象接口的情况下，客户通过查询或其他手段，
					获得服务对象的接口描述信息，然后使用动态调用接口（DII）
					来构造客户请求，并发送给对象实现。
				在对象实现方，可利用动态骨架接口（DSI）动态分发用户请求机制
				接口使用IDL定义，并置于接口库（IR）中
		
		ORB功能和操作：
			ORB初始化：
				当应用程序运行在CORBA环境时，需要对ORB和对象适配器POA进行初始化，
				ORB和POA的初始化是顺序执行的，ORB先于POA。
			ORB接口操作：
				这些操作定义在CORBA模块的接口ORB中，对象引用是用字符串形式存储和传送的，
				因此对象引用和其字符串形式之间的转换是必要的。
			获取初始对象引用：
				当ORB初次启动时，客户并不知道被调用对象实现的对象引用。没有对象引用
				就不能定位对象实现。因此ORB给出了获取初始对象引用的方法，应用可以
				调用它来获得初始对象引用。
			与线程有关的操作：
				为了支持单线程和多线程应用程序，ORB接口包含相关操作。
			策略设置与管理：
				CORBA的策略设置很灵活，从而增强了它的能力。
				策略的最初设置和覆盖为用户创造了合适的环境，也带来了设置和管理的复杂性。
			对象引用操作：
				对象引用是不透明的，在多次引用同一对象时，只能使用复制的方法，
				设置一计数器来跟踪对象引用的副本数。
					interface Object{
						interfaceDef get_interface();                   // 返回接口库中一个接口对象
						boolean is_nil();                               // 测试对象是否为空
						object duplicate();                             // 复制对象引用，对象引用计时器+1
						void release();                                 // 释放对象引用，对象引用计时器-1
						boolean is_equivalent(in Object other_object);  // 测试对象是否与other_object相等
					};
			静态调用的应用开发：
				OMG定义了IDL，实现标准的对象接口，构造分布式对象应用，使客户程序
				能调用远程服务器上对象的方法。
				IDL编译器将IDL接口定义翻译为目标语言代码。
		
2、IDL，能将IDL转换为Java的接口。
	IDL和java数据类型的转换（不同的）：
		java:  Int    Long         Java.lang.String
		IDL :  long   long long    string/wstring
	IDL接口：
		接口定义描述远程对象以及该对象的方法和成员变量，由关键字interface描述。
		interface JobManager{
			readonly attribute string FirstName;
			attribute string status;
			string QueryJobStatus(				// 操作参数包括参数名、参数的数据类型、参数的传送方向 
				in long Number,					// 传送方向in表示参数由客户提供
				out string property);			// 传送方向out表示参数由对象实现返回
												// inout表示由客户传送，经过对象实现修改，返回给客户
			void setStatus(in string status);   // 没有返回值out，可以使用关键字void指明
		};
		CORBA支持接口的继承，用冒号表示继承，一个接口可以继承多个接口：
			Interface Book: Product{}
		不能在CORBA接口里面设定变量，对象的数据表示是实现方法的组成部分，
		而IDL没有解决它的实现方法的问题。
	IDL模块：
		为了方便将逻辑上相关接口组合在一起的一种便捷方式。
		Module AccountTypes {
			interface UserAccount{};
			interface UserId{};
		};
	IDL特点：
		是一种规范语言
		看上去像C语言
		目的是定义接口和精简分布式对象的过程
		分离对象的接口与其实现
		剥离了编程语言和硬件的依赖性
		隐藏实现细节
		提供通用的数据类型
	IDL属性转化为Java表示：
		interface Book{
			attribute string isbn;
		};
		在java中的等价接口是一对get和set方法：
		String isbn();  
		Void isbn(String _isbn);   // 如果该属性为readonly，则不生成这个set方法
	IDL操作：
		IDL操作是模式定义中最重要的部分，可以远程调用这些操作，执行所需的简单或复杂任务。
		操作是可以在结束时返回值并接受参数的函数
		IDL操作的三种参数：in、out、inout
		IDL不支持方法的重载，必须为每个方法配备不同的名字。
	IDL异常操作：
		在CORBA中，异常不可以为子类。
		可以在一个模块中定义多个异常，可以在一个操作中抛出多个异常，用raises关键字
		module BankingSystem{
			exception AccountInactive{
				String reason;
			};
			exception AccountOverdrawn{
				String reason;
			};
			interface BankAccount{
				double withdrawMoney(in double amount) raises
				(AccountInactive);
				double withdrawMoney2(in double amount) raises
				(AccountInactive, AccountOverdrawn);
			}
		}
		
	把IDL映射到java：
		idlj编译器就是一个ORB，可以用来在java中定义、实现和访问CORBA对象。
		1. 指定生成文件的路径：
			idlj [-td C:\]cal.idl
		2. 生成客户端的类：
			idlj -fclient cal.idl
		3. 生成服务器端的类：
			idlj -fserver cal.idl
		4. 生成客户端和服务器端的类
			idlj -fall cal.idl
		CORBA Holder类：
			由于java没有out和inout的对应物，所以要提供一些附加的机制来支持值传递（并返回结果）
			映射定义Holder类，这些holder类在java中实现附加的参数传递模式。
				对每一个out或者inout参数，客户必须实例化一个适当的holder类的实例。
		生成文件：
			cal.java:
				接口标记文件，提供类型标记，使该接口可以用于其他接口的方法声明
			calOperations.java：
				Java公共接口，接口标记文件可扩展该接口
			calHelper.java：
				提供辅助功能，负责读写数据类型到CORBA流，以及插入和提取数据类型
			calHolder.java：
				一个专门化类，是为了需要通过引用来传递参数的任意数据类型而生成的。
			calPOA.java：
				服务器Skeleton
			calStub.java：
				客户端Stub
		CORBA属性：
			结构类型：
				Sequence（序列）：一个可变大小的一维元素序列，其中元素可以是
					任何idl的类型，可以限制最大长度
				Struct（结构）：可以使用结构将多种类型的命名字段组装在一起，每个
					Struct有2个构造函数，一个是默认的空构造函数，一个是把结构
					字段作为参数并初始化每个字段
				Union（联合）：用于在任何给定的时间只引用几个数据成员中的一个（
					任何时间，内存中只能有一个成员）
				Any：是一个保留其类型的自描述数据结构，可以在运行时用类型安全的
					转换函数提取和插入预定义的idl类型的值。Any可以指定一个属性值、
					参数或者返回类型，该类型包含一个在运行时而不是在编译时确定的
					任意类型，可以使用any传递任何东西
		服务端完成的任务：
			- 启动ORB
			- 查找并启动可移植的根对象适配器（POA）
			- 建立服务器的实现代码
			- 使用POA，将服务器的引用转换为CORBA对象的引用
			- 获取IOR
			- 将服务器的实现代码连接到命名服务程序
			- 等待客户端的调用
		客户的操作步骤：
			- 启动ORB
			- 检索一个对“NameService”的初始引用，并且将它的范围缩小为NamingContext的引用，
				以便找到该命名服务程序
			- 将对象和描述符组合起来，并且调用NamingContext类的resolve方法，找到
				想要调用的其方法的对象
			- 将返回的对象范围缩小为正确的类型，并且调用你的方法
		运行：
			编译：
				javac *.java
			运行服务端程序：
				启动名字服务器：
					tnameserv [-ORBInitialPort port] // port是ORB名字服务器的端口号，默认900
				启动服务程序：
					java server [-ORBInitialHost host] [-ORBInitialPost post]
			运行客户端程序：
				java client [-ORBInitialHost host] [-ORBInitialPost post]
		
	
3、RMI体系结构及应用开发。

面向对象的分布计算：
	客户/服务器模式，服务是用面向对象的方法实现的。分布式对象是一些位置透明、语言和
	平台队列的软件组件，通过互相发送消息实现请求服务。分布对象的设计目标是让用户和
	开发者享有“即插即用”的好处，对象自身无法提供这样的内部结构，需要为对象提供标准
	底层运行环境的支持。
	
分布式对象：
	分布式对象是一些独立代码的封装体，它向外提供了一个包括一组属性和方法的接口，
	远程客户程序通过远程方法调用来访问它。（要解决位于不同进程的对象之间的调用问题）
	特点：
		位置、实现的透明性
		语言、平台独立
		通过预先定义好的接口访问（互相发送消息实现请求服务）
		客户与服务器的角色划分是相对或多层次的
		分布式对象具有可在网络上移动的动态性

DCOM：
	COM：组件对象模型，定义了对象与其使用者用二进制标准接口进行交互的规范。
		可看作单机环境的对象请求代理。COM服务包括接口查询、生命周期管理、组件创建与许可、
		数据对象和结构化存储等。
		
		COM对象接口：
			- IUnknown接口：
				所有的COM对象都有一个特殊的接口IUnknown，其他接口都继承于它。
				IUnknown接口定义了三个成员函数：
					QueryInterface()：用于接口查询
					AddRef()：用于COM对象的生命周期控制
					Release()：用于COM对象的生命周期控制
			- 接口继承：
				COM对象都继承于IUnknown，并可以定义自己的成员函数
				接口标识符IID：是由COM生成的128位全局唯一标识（GUID）
			- 函数指针表：
				如果COM组件用C++实现，C++的纯抽象基类和COM接口有相同的内存块结构。
			- 接口查询：
				客户可以通过接口函数QueryInterface()查询对象所支持的接口IID，
				如果调用返回的HRESULT类型的变量hr置为成功（SUCCEDED(hr)==True），
				则在pIX中获得指向它们的指针（pIX->Fx()）。
			- COM对象生命周期：
				函数AddRef()和Release()实现了一个引用计数的内存管理计数。
		COM对象的动态链接：
			动态链接库DLL是一个组件服务器或组件发布方式，它拥有创建类工厂和
			组件的接口函数供客户调用。DLL是包含函数和数据模块的集合，它可通过
			静态链接或动态链接两种方式加载：
				静态链接：将所要链接的模块编译成二进制形式并与其他模块链接
				动态链接：调用模块于运行时，使用LoadLibrary()或LoadLibraryEx
					将DLL模块加载到进程地址空间。动态链接的优点是，节省存储空间
					并减少了交换，多个进程可共享单个DLL副本。
		COM对象创建：
			1. 创建类厂
			2. 创建组件
			3. 组件注册
		COM对象复用：
			COM提供了两种机制来支持组件的复用（P320）：
				包含/代理机制：
					外部对象把内部对象完全包装起来，调用内部对象的接口实现自己的服务
				聚合机制：
					外部对象把内部对象包起来，但是直接把内部对象的接口提供给客户
				当内部对象的接口和外部对象所需的某个接口相同时，应采用聚合机制，
				当接口不同但接口功能上有较多重叠时，应该采用代理机制
			COM的这些机制由COM库来实现：
				COM为客户应用与服务器对象之间建立链接
				链接建立后，客户和服务器之间直接进行交互
				系统的效率大为提高，但不利于系统动态重配置
		可互连对象和事件服务：
			COM定义了一种发送接口，通过该接口，服务器可以与客户进行双向对话。
			当一个对象支持发送接口时，称之为可互连对象
			每个发送接口由多个远程成员函数组成，每个函数表示事件、通知或请求。
			要求客户能够监听服务器对象发出的事件或请求，并处理它。
			客户对象需要实现一个称为Sink的接口，以监听服务器的事件或请求。
			可互联对象为COM提供了标准事件服务。
		COM基础设施：
			持久存储：
				COM定义了标准的持久存储接口，实现这些接口的对象可以将对象的状态存放到
				持久存储设备上，从而在一段时间以后恢复对象状态。
			一致性数据传输：
				定义了客户和服务器之间交换数据的标准接口
				客户对象也可以利用这些接口在服务器对象中登记，使得当数据改变时，
					服务器对象可以主动通知它。
			智能名字（标志Moniker）：
				智能名字将名字及对其相关的操作封装在一起，并成为实现名字相关的接口的对象。
				为分布式文件名、远程计算机、文档段落等对象提供持久别名。
				客户可以将一个支持IMoniker接口的对象进行特殊的实例化，从而允许客户
					在将来重新连接到这个对象。
			
	DCOM：分布式组件对象模型，是COM网络环境下的扩充，DCOM提供本地/远程访问的透明性，
		且不破坏原有的OLE对象。
		
		DCOM服务器的实现方式（P323）：
			进程内服务器：
				服务器可以加载到客户方的进程空间中，以进程内对象的形式提供服务。
			本地服务器：
				服务器是同一台机器上的另外一个进程，以exe文件方式存在和运行。
				当客户进程需要和服务器通信时，不直接调用服务器中组件。它必须遵循
				进程间通信规定，由操作系统拦截客户进程调用，并将其转发到服务器。
			远程服务器：
				服务器运行在另外一台机器上，既可以是动态链接库，也可以是可执行文件。
				DCOM以网络协议通信代替本地进程间通信。
		DCOM主要特点：
			- 支持多种通信协议
			- 多语言支持
			- DCOM将基于认证的internet安全机制和基于NT的C2级安全机制集成在一起，
				使组件通信有安全保障。

分布式对象系统比较：
	对象模型：
		CORBA是基于经典对象模型的、支持多继承、封装和多态
		COM是基于对象的，只支持封装机制，并不支持IDL描述的多继承
		RMI是针对java的分布式计算，与CORBA相比能提供很好的容错能力和对异常的处理
	对象系统对比：
		CORBA和COM对象都支持本地和远程的静态方法调用
		CORBA总线支持本地和远程的动态调用
		COM通过Idispatch支持本地的动态调用，DCOM支持远程的动态调用
		CORBA和COM都将对象的接口和实现相分类，并要求所有接口由接口定义语言描述，
			它们的接口都是客户与服务器之间的协定，支持跨地址空间的函数调用

========================================================================
第十二章
1、Web服务的概念
2、什么是Web服务契约，服务功能描述、服务访问描述、服务位置描述的组成。
3、SOAP、WSDL、UDDI的概念
4、Web服务应用开发

SOAP报文：
	SOAP请求：
		<?xml version="1.0"?>
		<soap:Envelope xmlns: soap="http://www.w3c.org/2001/12/soap-envelope" // 名字空间，始终是这个值
						soap:encodingStyle="http:www.s3c.org/2001/12/soap-encoding"> // 文档数据类型
			<soap:Header>
				头标消息
				<m:Trans
					xmlns:m="http://www.w3school.com.cn/transaction/"
					soap:encodingStyle="http:www.s3c.org/2001/12/soap-encoding"  // 文档数据类型
					soap:actor="http://www.w3school.com.cn/appml/"  // actor="URI" 被用于将 Header 元素寻址到一个特定的端点
					soap:mustUnderstand="1">234</m:Trans>   // mustUnderstand=1，表示消息接收者该头部项是必须的
				// 上面的例子包含了一个带有一个 "Trans" 元素的头部，它的值是 234.
			</soap:Header>
			
			<soap:Body>
				消息内容...
			   <m:GetPrice xmlns:m="http://www.w3school.com.cn/prices">
				  <m:Item>Apples</m:Item>
			   </m:GetPrice>
			   // 上面的例子请求苹果的价格。请注意，上面的 m:GetPrice 和 Item 元素是应用程序专用的元素。
			   // 它们并不是 SOAP 标准的一部分。
				<soap:Fault>错误和状态信息...</soap:Fault>
			</soap:Body>
		</soap:Envelope>
	
SOAP实例：
	一个 GetStockPrice 请求被发送到了服务器。此请求有一个 StockName 参数，
	而在响应中则会返回一个 Price 参数。
	此功能的命名空间被定义在此地址中： "http://www.example.org/stock"

	POST /InStock HTTP/1.1
	Host: www.example.org
	Content-Type: application/soap+xml; charset=utf-8
	Content-Length: nnn

	<?xml version="1.0"?>
	<soap:Envelope
	xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
	soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

	  <soap:Body xmlns:m="http://www.example.org/stock">
		<m:GetStockPrice>
		  <m:StockName>IBM</m:StockName>
		</m:GetStockPrice>
	  </soap:Body>
	  
	</soap:Envelope>
	--------------------------------------------------------------------
	HTTP/1.1 200 OK
	Content-Type: application/soap+xml; charset=utf-8
	Content-Length: nnn

	<?xml version="1.0"?>
	<soap:Envelope
	xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
	soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

	  <soap:Body xmlns:m="http://www.example.org/stock">
		<m:GetStockPriceResponse>
		  <m:Price>34.5</m:Price>
		</m:GetStockPriceResponse>
	  </soap:Body>
	  
	</soap:Envelope>






